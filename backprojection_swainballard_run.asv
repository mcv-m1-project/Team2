function b = backprojection_swainballard_run(image, M, gridx, gridy, colorspace, r)


% Transform data to specified color space:
if(strcmp(colorspace, 'lab'))
    Xfinal = rgb2lab(Ximage / 255);
    % I keep only columns 2 and 3:
    Xfinal = Xfinal(:,2:3);
elseif(strcmp(colorspace, 'hsv'))
    Xfinal = rgb2hsv(Ximage / 255);
    % I keep only columns 1 and 2:
    Xfinal = Xfinal(:,1:2);
else
    error('Color space not recognized.')
end

% Create matrix with pixels of image:
npixels = size(image, 1) * size(image, 2);
Ximage = zeros(npixels, 3);
idx = 0;
for i = 1:size(image, 1)
    for j = 1:size(image, 2)
        idx = idx + 1;
        Ximage(idx,:) = image(i, j, :);
    end
end

% Compute histogram of input image:
I = hist3(Xfinal, [{gridx}, {gridy}]);

% Ratio of histograms:
R = M ./ I;

% Taking the minimum with the image:
nrow = size(image, 1);
ncol = size(image, 2);
bprime = zeros(nrow, ncol);
for i = 1:nrow
    for j = 1:ncol
        % Find position in R for pixel (i,j) of the image:
        labpixel = rgb2lab
        igridx = min();
        bprime(i,j) = min(R(i,j), 1);
    end
end

% We definde the disk of radius r:
D = zeros(2*r+1, 2*r+1);
for i = 1:(2*r+1)
    for j = 1:(2*r+1)
        if((i-r-1)^2 + (j-r-1)^2 <= r^2)
            D(i,j) = 1;
        end
    end
end

% Convolution:
b = conv2(bprime, D);

figure()
subplot(1,2,1)
imshow(I, [min(min(I)), max(max(I))])
title('I')
subplot(1,2,2)
imshow(b, [min(min(b)), max(max(b))])
title('b')

return

end