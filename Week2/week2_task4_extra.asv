%%%%%%%%%%%%%%%%%%%%%%%%%
%%% *****

clear all
close all

% Base path:
dirbase = pwd;
% Path do data set:
dirimage = [dirbase, '\..\..\train'];
% Path to Ground Truth annotations:
dirgt = [dirimage, '\gt'];
% Path to Masks:
dirmask = [dirimage, '\mask'];

% We add the path where some scripts are.
addpath([dirbase, '\..\evaluation\'])
addpath([dirbase, '\auxilar\'])

% Load signals vector.
load('signals_workspace');

% Train / validation split:
[trainSet, validationSet] = train_validation_split(dirimage, nrepetitions);

% Creating train files lists:
ntrain = length(trainSet);
train_image_list = cell(1, ntrain);
train_mask_list = cell(1, ntrain);
for i = 1:ntrain
    train_image_list{i} = [trainSet{i}, '.jpg'];
    train_mask_list{i} = ['\mask.', trainSet{i}, '.png'];
end

% Create training signals vector, separeted by group:
countABC = 0;
countDF = 0;
countE = 0;
for i = 1:length(signals)
    tag = 0;
    % We check if this signal belongs to the training set:
    for j = 1:length(trainSet)
        if(~isempty(strfind(signals(i).filename, trainSet{j})))
            tag = 1;
            break
        end
    end
    if(tag == 1)
        % Switch depending on signal type:
        switch signals(i).type
            case {'A', 'B', 'C'}
                countABC = countABC + 1;
                train_signalsABC(countABC) = signals(i);
                
            case {'D', 'F'}
                countDF = countDF + 1;
                train_signalsDF(countDF) = signals(i);
                
            case 'E'
                countE = countE + 1;
                train_signalsE(countE) = signals(i);
                
            otherwise
                error('Signal type not recognized')
        end
    end
end

% Separating images and masks lists:

% ABC
train_mask_list_ABC = cell(0);
train_image_list_ABC = cell(0);
countABC = 0;
for i = 1:length(train_signalsABC)
    % Check if the filename is already in the list:
    flag = 0;
    for j = 1:length(train_image_list_ABC)
        if(~isempty(strfind(train_image_list_ABC{j}, train_signalsABC(i).filename)))
            flag = 1;
            break
        end
    end
    if(flag == 0)
        countABC = countABC + 1;
        train_image_list_ABC{countABC} = [train_signalsABC(i).filename, '.jpg'];
    end
end

% DF
train_mask_list_DF = cell(0);
train_image_list_DF = cell(0);
countDF = 0;
for i = 1:length(train_signalsDF)
    % Check if the filename is already in the list:
    flag = 0;
    for j = 1:length(train_image_list_DF)
        if(~isempty(strfind(train_image_list_DF{j}, train_signalsDF(i).filename)))
            flag = 1;
            break
        end
    end
    if(flag == 0)
        countDF = countDF + 1;
        train_image_list_DF{countDF} = [train_signalsDF(i).filename, '.jpg'];
    end
end

% E
train_mask_list_E = cell(0);
train_image_list_E = cell(0);
countE = 0;
for i = 1:length(train_signalsE)
    % Check if the filename is already in the list:
    flag = 0;
    for j = 1:length(train_image_list_E)
        if(~isempty(strfind(train_image_list_E{j}, train_signalsE(i).filename)))
            flag = 1;
            break
        end
    end
    if(flag == 0)
        countE = countE + 1;
        train_image_list_E{countE} = [train_signalsE(i).filename, '.jpg'];
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TRAINING

% Minimum recall:
min_recall = 0.5;

% Selecting parameters and training all methods with ABC images:
bp_select_minrecall(min_recall, train_signalsABC, train_image_list_ABC, dirimage, train_mask_list_ABC, dirmask)
load('bp_sb_final.mat')
save('bp_sb_final_ABC.mat', 'M', 'gridx', 'gridy', 'colorspace', 'prctile_ths', 'r')
load('bp_mod_final.mat')
save('bp_mod_final_ABC.mat', 'R', 'gridx', 'gridy', 'colorspace', 'prctile_ths')
load('bp_kde_final.mat')
save('bp_kde_final_ABC.mat', 'R', 'gridx', 'gridy', 'colorspace', 'prctile_ths')

% Selecting parameters and training all methods with DF images:
bp_select_minrecall(min_recall, train_signalsDF, train_image_list_DF, dirimage, train_mask_list_DF, dirmask)
load('bp_sb_final.mat')
save('bp_sb_final_DF.mat', 'M', 'gridx', 'gridy', 'colorspace', 'prctile_ths', 'r')
load('bp_mod_final.mat')
save('bp_mod_final_DF.mat', 'R', 'gridx', 'gridy', 'colorspace', 'prctile_ths')
load('bp_kde_final.mat')
save('bp_kde_final_DF.mat', 'R', 'gridx', 'gridy', 'colorspace', 'prctile_ths')

% Selecting parameters and training all methods with E images:
bp_select_minrecall(min_recall, train_signalsE, train_image_list_E, dirimage, train_mask_list_E, dirmask)
load('bp_sb_final.mat')
save('bp_sb_final_E.mat', 'M', 'gridx', 'gridy', 'colorspace', 'prctile_ths', 'r')
load('bp_mod_final.mat')
save('bp_mod_final_E.mat', 'R', 'gridx', 'gridy', 'colorspace', 'prctile_ths')
load('bp_kde_final.mat')
save('bp_kde_final_E.mat', 'R', 'gridx', 'gridy', 'colorspace', 'prctile_ths')


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMPUTING AND WRITING MASKS
for i = 1:length(testSet)
    imagefile = [dirtest, test_image_list{i}];
    imread(imagefile);
    
    %%%% Swain-Ballard %%%
    % ABC
    load('bp_sb_final_ABC.mat')
    maskABC = backprojection_sb_run(image, M, gridx, gridy, colorspace, r, prctile_ths);
    % DF
    load('bp_sb_final_DF.mat')
    maskDF = backprojection_sb_run(image, M, gridx, gridy, colorspace, r, prctile_ths);
    % E
    load('bp_sb_final_E.mat')
    maskE = backprojection_sb_run(image, M, gridx, gridy, colorspace, r, prctile_ths);
    % Joining them:
    mask_sb = maskABC | maskDF | maskE;
    % Writing mask:
    imwrite(mask_sb, [dirmaskwrite_sb, ])
    
    
    
end







