% function [mask, windowCandidates] = slidingWindow_edges(image_edges, width0, height0, stepW0, stepH0, sizesrange, thresholdDT)
function windowCandidates = slidingWindow_edges(image_edges, width0, height0, stepW0, stepH0, sizesrange, thresholdDT)

% Initializing structures:
windowCandidates = [];
windows = [];
candidates = [];
score = [];

% Loading Distance Transforms of model signals:
load('DTModels.mat')

% Size of image:
[N, M] = size(image_edges);

% Initialize cell array with the Distance Transform models. In this cell
% array, these models will be resized, so they will not be the same as the
% ones loaded previously.
DT = cell(4);

% Loop over sizes:
for sizefactor = sizesrange
    % Resizing width and height:
    height = max(round(height0 * sizefactor), 1);
    width = max(round(width0 * sizefactor), 1);
    % Resizing the steps:
    stepW = max(round(stepW0 * sizefactor), 1);
    stepH = max(round(stepH0 * sizefactor), 1);
    % Resizing threshold (to be consisten with the size of the window):
    thresholdDT_resized = 
    
    % Adjust size of DT to fit the windows:
    DT{1} = imresize(circleDT, [height, width]);
    DT{2} = imresize(squareDT, [height, width]);
    DT{3} = imresize(upTriangleDT, [height, width]);
    DT{4} = imresize(downTriangleDT, [height, width]);

    % Trying all windows over the image:
    for n = 1 : stepH : N-height+1
        for m = 1 : stepW : M-width+1
            % Content of the image in the window:
            subIm = image_edges(n : n+height-1, m : m+width-1);

            % We try with the four different signals shapes:
            % (circle, square, and up and down triangles)
            minWindowScore = 0;
            for signal_shape = 1:4
                % Sum of product of the Distance Transform and the edges in 
                % the window:
                windowScore = sum(sum(DT{signal_shape} .* subIm));
                
                % Minimum score between the different shapes:
                minWindowScore = min(minWindowScore, windowScore);
            end

            % Deciding if the window is a candidate:
            if(minWindowScore < thresholdDT_resized)
                windows = [windows, struct('x', m, 'y', n, 'w', width, 'h', height)];
%                 candidates = [candidates; m, n, width, height];
%                 score = [score; minWindowScore];
            end
        end
    end
end


% Delete overlapped detections (union)
imPos = 1:M*N;
imPos = reshape(imPos,[N,M]);
if(0 == isempty(windows))
    % We directly add the first window:
    windowCandidates = windows(1);
    
    % Loop over the rest of the cadidate windows:
    for winPos = 2:length(windows)
        % Coordinates of current window:
        x_pos = windows(winPos).x;
        y_pos = windows(winPos).y;
        w_pos = windows(winPos).w;
        h_pos = windows(winPos).h;
        rectPos = imPos(y_pos : y_pos + h_pos - 1, x_pos : x_pos + w_pos - 1);
        
        % Flag to check if the window is new or if it is overlapped with
        % any other previously added:
        new = 1;
        
        % Loop over the previously selected windows:
        for winDef = 1:length(windowCandidates)
            % Coordinates of "Def" window:
            x_def = windows(winDef).x;
            y_def = windows(winDef).y;
            w_def = windows(winDef).w;
            h_def = windows(winDef).h;
            rectDef = imPos(y_def : y_def + h_def - 1, x_def : x_def + w_def - 1);
            
            % Intersection of both windows:
            int = intersect(rectPos, rectDef);
            if (0 == isempty(int)) %No empty means that both evaluated windows are overlapped
                new = 0;
                % Union of both windows:
                uni = union(rectPos, rectDef);
                [minY, minX] = find(imPos==min(uni));
                [maxY, maxX] = find(imPos==max(uni));
                winFin = struct('x', minX, 'y', minY, 'w', maxX-minX+1, 'h', maxY-minY+1);
                windowCandidates(winDef) = winFin;
                break;
            end
        end
        
        % If the window is not overlapped with any other, we consider it:
        if(new == 1)
            windowCandidates = [windowCandidates windows(winPos)];
        end
    end
end

% % Generate the final mask
% mask = zeros(N,M);
% for winDef = 1:length(windowCandidates)
%     % Coordinates of current window:
%     x = windowCandidates(winDef).x;
%     y = windowCandidates(winDef).y;
%     w = windowCandidates(winDef).w;
%     h = windowCandidates(winDef).h;
%     mask(y:y+h-1, x:x+w-1) = image_edges(y:y+h-1, x:x+w-1);
% end

end



